#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"},{"aliases":[],"languageName":"fsharp","name":"fsharp"}]}}

#!markdown

# 23 a maze

#!fsharp

#load "Aoc.fsx"

let input = Aoc.fetchInput 23

let testInput = "#.#####################
#.......#########...###
#######.#########.#.###
###.....#.>.>.###.#.###
###v#####.#v#.###.#.###
###.>...#.#.#.....#...#
###v###.#.#.#########.#
###...#.#.#.......#...#
#####.#.#.#######.#.###
#.....#.#.#.......#...#
#.#####.#.#.#########v#
#.#...#...#...###...>.#
#.#.#v#######v###.###v#
#...#.>.#...>.>.#.###.#
#####v#.#.###v#.#.###.#
#.....#...#...#.#.#...#
#.#########.###.#.#.###
#...###...#...#...#.###
###.###.#.###v#####v###
#...#...#.#.>.>.#.>.###
#.###.###.#.###.#.#v###
#.....###...###...#...#
#####################.#
"

#!markdown

## parse!

another grid type with fast neighbor lookup. could be a 2D array.

#!fsharp

type Direction = Up | Down | Left | Right
type Tile = Path | Forest | Slope of Direction
type Point = int * int
type Grid = Map<Point, Tile>

let parse (input: string) : Grid =
  seq { for y, line in Array.indexed <| input.Split('\n') do
          for x, c in Seq.indexed line do
            (x,y),
            match c with
            | '#' -> Forest
            | '.' -> Path
            | '>' -> Slope Right
            | '<' -> Slope Left
            | '^' -> Slope Up
            | 'v' -> Slope Down
            | _ -> failwith "invalid input" } |> Map.ofSeq

parse testInput

#!fsharp

module Part1 =
  let neighbors (x,y) (grid: Grid) : Point list =

    let choose (direction, pt) =
      Map.tryFind pt grid
      |> function
        | Some (Slope slopeDirection) when direction = slopeDirection -> Some pt
        | Some Path -> Some pt
        | _ -> None

    [ Left, (x-1,y); Right, (x+1,y); Up, (x,y-1); Down, (x,y+1) ]
    |> List.choose choose

#!fsharp

let rows : Grid -> int =
  Map.toSeq >> Seq.map (fst >> snd) >> Seq.max

let print (grid: Grid) (path: Point Set) =
  let rows = rows grid
  let cols = grid |> Map.toSeq |> Seq.map (fst >> fst) |> Seq.max
  seq { for y in 0..rows do
          System.Environment.NewLine
          for x in 0..cols do
            match Map.tryFind (x,y) grid with
            | _ when Set.contains (x,y) path -> "O" 
            | Some Forest -> "#"
            | Some Path -> "."
            | Some (Slope Right) -> ">"
            | Some (Slope Left) -> "<"
            | Some (Slope Up) -> "^"
            | Some (Slope Down) -> "v"
            | None -> " "
  } |> String.concat "" |> printfn "%s"

let findStartStop grid =
  let lastRow = rows grid

  let findStartStop ((start, stop): Point option * Point option) : Point*Tile -> Point option * Point option =
    function
    | ((_, 0) as pt, Path) when start = None -> Some pt, stop
    | ((_, y) as pt, Path) when stop = None && y = lastRow -> start, Some pt
    | _ -> start, stop

  grid
  |> Map.toSeq
  |> Seq.fold findStartStop (None, None)
  |> function
     | Some start, Some stop -> Some (start,stop)
     | _ -> None

#!fsharp

module Part1 =
  let traverse start (grid: Grid) =
    let neighbors (pt: Point) : Point Set = grid |> Part1.neighbors pt |> Set.ofList

    let rec loop completed : (Point*Point Set) list -> (Point Set) list =
      function
      | [] -> completed
      | (start,path) :: paths ->
        let visited = Set.add start path
        match path |> Set.difference (neighbors start) |> Set.toList with
        | [] -> loop (visited::completed) paths
        | neighbor :: neighbors -> loop completed ((neighbor, visited) :: (paths @ [for neighbor in neighbors -> neighbor, visited]))

    loop [] [start, Set.empty]

  let solve grid =
    let map (start,stop) =
      (grid |> traverse start |> List.filter (Set.contains stop) |> List.map Set.count |> List.max) - 1
    grid |> findStartStop |> Option.map map

#!fsharp

let testGrid = parse testInput

Part1.solve testGrid

#!fsharp

input |> parse |> Part1.solve

#!markdown

## Part 2

More possible paths.

Ok. Not to be too hammer so everything is a nail, but isn't this a case for a _reverse_ dijksta? like, a priority queue that will return the longest path to any point?

#!fsharp

module Part2 =
  let neighbors (x,y) (grid: Grid) : Point list =

    let choose pt =
      Map.tryFind pt grid
      |> function
        | Some (Slope _) -> Some pt
        | Some Path -> Some pt
        | _ -> None

    [x-1,y; x+1,y; x,y-1; x,y+1]
    |> List.choose choose
